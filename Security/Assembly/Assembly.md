## 어셈블리어


### 기본 명령어

| 명령어 | 설명 |
|:----------|:----------|
| `CALL XXX` | XXX 주소의 함수를 호출 |
| `JMP XXX` | XXX 주소로 점프(이동) |
| `PUSH XXX` | 스택에 XXX 저장 |
| `RETN` | 스택에 저장된 복귀주소로 점프(이동) |
| `INC` | 값을 1 증가 |
| `DEC` | 값을 1 감소 |




### 분기 명령어

| 명령어 | 설명 |
|:----------|:----------|
| `JE XXX` | 조건 분기(Jump if Equal)<br>ZF=1이면 XXX로 점프 |
| `CMP X, Y` | 두 개의 피연산자(X, Y) 비교<br>`SUB`명령어와 동일하나 피연산자값이 변경되지 않고 EFLAGS 레지스터만 변경됨 두 피연산자의 값이 동일하다면 `SUB`결과는 0이고 ZF=1로 세팅 |
| `TEST X, Y`| 논리비교 <br> `AND` 연산과 동일 <br> 피연산자값이 변경되지 않고 EFLAGS 레지스터만 변경됨 <br> 두 피연산자 중에 하나가 0이면 `AND`연산 결과는 0. ZF=1로 세팅됨|




### 연산 명령어
| 명령어 | 설명 |
|:----------|:----------|
| `MOV X, *Y` | Y값을 X에 대입(=복사) |
| `LEA X, &Y` | Y값을 가리키는 **스택공간의 주소값**을 X에 대입 |




### 기타 명령어

| 명령어 | 설명 |
|:----------|:----------|
| `NOP` | No Operation : 아무 동작을 하지 않는 명령어 <br> 그냥 CPU 클럭만 소모 <br> VB파일에 함수와 함수 사이에 `NOP`명령어가 존재  |


### 스택 명령어

| 명령어 | 설명 |
|:----------|:----------|
| `PUSHAD` | 범용 레지스터의 값들을 스택에 저장 <br> 스택에 들어가는 순서 : EAX → ECX → EDX → EBX → ESP → EBP → ESI → EDI



### etc
* `TEST X, X`와 같이 왜 똑같은 것을 비교하는가? <br>
X가 0인지 체크하기 위해서이다. 어셈블리 문법의 특징이라고 생각하면 된다. 
```
# Assembly
TEST AX, AX
JE 4030408
```
위 어셈블리 코드를 C언어로 해석하면 아래와 같다.
```
// C
If (AX == 0)
    goto 4030408
```